library("tidyverse")
library("here")
library("edgeR")
here()
setwd(here())
data_gene_level <- read_csv(here("4-class4",
"data",
"input",
"data_gene-level.csv"))
names(data_gene_level)
geneExpr <- data_gene_level %>% #pipe data to next step
select(-X1, -hgnc_symbol) %>% #Remove row# column and gene symbol
rename(id = ensembl_gene_id) %>% #rename the ensembl_gene_id to id
filter(!is.na(id)) # remove rows with no gene ids.
geneExpr <- data.frame(geneExpr) #we are converting the geneExpr tibble to a data.frame for a specific reason. Tibbles do not allow a variable to be contained in a row name. Therefore, they don't allow row names at all. But for edgeR to work, we need the count data to be in a matrix with gene names as row names and sample names as column names.
row.names(geneExpr) <- geneExpr$id # This is where we move the gene id information into row name
x <- geneExpr[, c(2:13)] # then, we get rid of the column containing gene id. Thus, generating out matrix of count data.
x_set <- x[, c(1:3, 10:12)]
knitr::opts_chunk$set(echo = TRUE)
group_set <- c(1, 1, 1, 2, 2, 2)
y_set <- DGEList(counts=x_set, group=group_set)
keep <- rowSums(cpm(y_set)>1) >= 3
y_set <- y_set[keep, , keep.lib.sizes=FALSE]
y1_set <- calcNormFactors(y_set)
y1_set
design_set <- model.matrix(~group_set)
#estimate dispersion
y2_set <- estimateDisp(y1_set, design_set, verbose=TRUE)
y2_set
#find DE genes
fit_set1 <- glmFit(y2_set1, design_set1, verbose=TRUE)
#find DE genes
fit_set <- glmFit(y2_set, design_set, verbose=TRUE)
lrt.2vs1_set <- glmLRT(fit_set, coef=2) #coef specifies ?
DUX4_14h <- topTags(lrt.2vs1_set, n=10733) #n specifies number of genes to view
DUX4_14h <- topTags(lrt.2vs1_set, n=10)
DUX4_14h
y1_set <- estimateCommonDisp(y1_set, verbose=T)
names(y1_set)
x <- geneExpr[, c(2:13)] # then, we get rid of the column containing gene id. Thus, generating out matrix of count data.
# Subsetting the data to only consider 0 vs 14 hour for our fold-change calculations
x <- x[, c(1:3, 10:12)] #keeping 0h and 14h samples only
group <- c(1, 1, 1, 2, 2, 2)
d <- DGEList(counts=x, group=group)
cpm(d)
head(cpm(d))
head(d)
head(d$counts)
rowSums(cpm(d)>1)
head(rowSums(cpm(d)>1))
keep <- rowSums(cpm(d)>1) >= 3
head(keep)
nrow(keep)
n(keep)
keep %>% count()
keep %>% count(.)
d
d <- calcNormFactors(d)
d
# create a model matrix
design <- model.matrix(~group)
#estimate dispersion
d <- estimateDisp(d, design)
d
#find DE genes
d <- glmFit(d, design)
d
# Subsetting the data to only consider 0 vs 14 hour for our fold-change calculations
x <- x[, c(1:3, 10:12)] #keeping 0h and 14h samples only
x <- geneExpr[, c(2:13)] # then, we get rid of the column containing gene id. Thus, generating out matrix of count data.
# Subsetting the data to only consider 0 vs 14 hour for our fold-change calculations
x <- x[, c(1:3, 10:12)] #keeping 0h and 14h samples only
group <- c(1, 1, 1, 2, 2, 2)
d <- DGEList(counts=x, group=group)
keep <- rowSums(cpm(d)>1) >= 3
d <- d[keep, , keep.lib.sizes=FALSE] # remove the rows that don't have sufficient cpm
d <- calcNormFactors(d) # calculate the normalization factor
# create a model matrix
design <- model.matrix(~group)
#estimate dispersion
d <- estimateDisp(d, design)
d
#find DE genes
d1 <- glmFit(d, design)
d1
d2 <- glmLRT(d1, coef=2) #coef specifies ?
d2
names(d1)
names(d2)
d2$table
head(d2$table)
names(d2)
head(d2$comparison)
d2$coefficients
d2$comparison
names(d2)
d2$df.test
head(topTags(d2, n=10733))
head(topTags(d2, n=10733))
d2 <- glmLRT(d1, coef=2) #coef specifies ?
d2
DUX4_14h <- topTags(d2, n=10733) #n specifies number of genes to view
DUX4_14h
topTags(d2, n=10733)
head(topTags(d2, n=10733))
names(DUX4_14h$table)
## Assemble final data structure for ploting figures
foldchange_hour14 <- cbind(id = row.names(DUX4_14h$table), DUX4_14h$table)
names(foldchange_hour14)
library(readr)
id_mapping <- read_csv("1-class1/data/input/id-mapping.csv")
View(id_mapping)
names(id_mapping)
id_mapping <- id_mapping[, c(2, 4)]
head(id_mapping)
names(id_mapping) <- c("id", "hgnc_symbol")
write_csv(id_mapping, file = "4-class4/data/id2gene.csv")
write.csv(id_mapping, file = "4-class4/data/id2gene.csv")
id2gene <- read_csv("4-class4/data/input/id2gene.csv")
here()
setwd(here())
id2gene <- read_csv("4-class4/data/input/id2gene.csv")
getwd()
write.csv(id2gene, file = "4-class4/data/input/id2gene.csv")
id2gene <- id_mapping
write.csv(id2gene, file = "4-class4/data/input/id2gene.csv")
## Assemble final data structure for ploting figures
foldchange_hour14 <- cbind(id = row.names(DUX4_14h$table), DUX4_14h$table)
id2gene <- read_csv("4-class4/data/input/id2gene.csv")
foldchange <- merge(id2gene, foldchange_hour14, by = "id")
head(foldchange)
nrow(fold)
nrow(foldchange)
nrow(foldchange_hour14)
foldchange <- unique(foldchange)
nrow(foldchange)
foldchange <- right_join(id2gene, foldchange_hour14, by = "id")
nrow(foldchange)
## Assemble final data structure for ploting figures
foldchange_hour14 <- cbind(id = row.names(DUX4_14h$table), DUX4_14h$table)
nrow(foldchange_hour14)
id2gene <- read_csv("4-class4/data/input/id2gene.csv")
nrow(id2gene)
nrow(unique(id2gene))
foldchange <- left_join(foldchange_hour14, id2gene, by = "id")
nrow(foldchange)
names(foldchange_hour14)
View(data_gene_level)
## Assemble final data structure for ploting figures
foldchange_hour14 <- cbind(id = row.names(DUX4_14h$table), DUX4_14h$table)
foldchange <- left_join(data_gene_level, foldchange_hour14, by = c("ensembl_gene_id" = "id"))
View(foldchange_hour14)
View(foldchange)
group <- c(1, 1, 1, 2, 2, 2)
design <- model.matrix(~group)
design
group <- factor(c(1, 1, 1, 2, 2, 2))
design <- model.matrix(~group)
design
d <- DGEList(counts=x, group=group)
d
keep <- rowSums(cpm(d)>1) >= 3 # identify the rows to keep that have cpm() > 1
d <- d[keep, , keep.lib.sizes=FALSE] # remove the rows that don't have sufficient cpm
d <- calcNormFactors(d) # calculate the normalization factor
d
d <- estimateDisp(d, design)
d
d1 <- glmFit(d, design)
d2 <- glmLRT(d1, coef=2) #coef specifies ?
DUX4_14h <- topTags(d2, n=10733)
View(DUX4_14h)
DUX4_14h
names(DUX4_14h)
names(DUX4_14h$table)
nrow(DUX4_14h$table)
foldchange_hour14 <- cbind(id = row.names(DUX4_14h$table), DUX4_14h$table)
View(foldchange)
View(foldchange_hour14)
View(foldchange)
foldchange.old <-
foldchange_hour14
foldchange.new <- left_join(data_gene_level, foldchange_hour14, by = c("ensembl_gene_id" = "id"))
View(foldchange.new)
View(foldchange.old)
foldchange.old <- left_join(data_gene_level, foldchange.old, by = c("ensembl_gene_id" = "id"))
View(foldchange.old)
View(foldchange.new)
View(foldchange.old)
diff(foldchange.new$logFC, foldchange.old$logFC)
Compare(foldchange.new$logFC, foldchange.old$logFC)
?estimateDisp
?calcNormFactors
knitr::opts_chunk$set(echo = TRUE)
library("tidyverse")
library("here")
library("edgeR")
here()
setwd(here())
knitr::include_graphics(here("4-class4", "images", "rnaseq-pipeline.png"), dpi = 200)
data_gene_level <- read_csv(here("4-class4",
"data",
"input",
"data_gene-level.csv"))
geneExpr <- data_gene_level %>% #pipe data to next step
select(-X1, -hgnc_symbol) %>% #Remove row# column and gene symbol
rename(id = ensembl_gene_id) %>% #rename the ensembl_gene_id to id
filter(!is.na(id)) # remove rows with no gene ids.
geneExpr <- data.frame(geneExpr) #we are converting the geneExpr tibble to a data.frame for a specific reason. Tibbles do not allow a variable to be contained in a row name. Therefore, they don't allow row names at all. But for edgeR to work, we need the count data to be in a matrix with gene names as row names and sample names as column names.
row.names(geneExpr) <- geneExpr$id # This is where we move the gene id information into row name
x <- geneExpr[, c(2:13)] # then, we get rid of the column containing gene id. Thus, generating out matrix of count data.
# 1. Subsetting the data to only consider 0 vs 14 hour for our fold-change calculations
x <- x[, c(1:3, 10:12)] #keeping 0h and 14h samples only
#Note: You can create as many sets as you want for the different comparisions you want to make, such as x1, x2, and so on. Just make sure to do the following steps also for each of the sets you made.
# 2. Define sample grouping
group <- factor(c(1, 1, 1, 2, 2, 2))
#Note: If you made more than one sets, you need to define their grouping individually as group1, group2, etc.
# 3. Generate a DGE list
d <- DGEList(counts=x, group=group)
# 4. Filter genes with low counts (require >1 cpm in at least 1/2 of the samples) & normalize
keep <- rowSums(cpm(d)>1) >= 3 # identify the rows to keep that have cpm() > 1
d <- d[keep, , keep.lib.sizes=FALSE] # remove the rows that don't have sufficient cpm
# 5. Calculate normalization factors to scale the raw library sizes.
d <- calcNormFactors(d)
# 6. create a model matrix to allow linear modeling
design <- model.matrix(~group)
# 7. estimate dispersion
d <- estimateDisp(d, design)
# 8. Fit a generalized linear model
d1 <- glmFit(d, design)
# 9. Conduct Tagwise likelihood ratio tests for DGEGLM
d2 <- glmLRT(d1, coef=2)
# 10. Extract the most differentially expressed genes (or sequence tags) from a test object, ranked either by p-value or by absolute log-fold-change.
DUX4_14h <- topTags(d2, n=10733)
## Assemble final data structure for ploting figures
foldchange_hour14 <- cbind(id = row.names(DUX4_14h$table), DUX4_14h$table)
foldchange <- left_join(data_gene_level, foldchange_hour14, by = c("ensembl_gene_id" = "id"))
foldchange <- unique(foldchange)
d
sqrt(d$common.dispersion)
plotBCV(d)
d$samples
